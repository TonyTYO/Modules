# -------------------------------------------------------------------------------
# Name:        mouse_c
# Purpose:     Allows program to control mouse
# Author:      Tony
# Created:     16/02/2021
# Copyright:   (c) Tony 2021
# Licence:     Free to use
# -------------------------------------------------------------------------------

# ! /usr/bin/env python

""" Allows program to control mouse
    Dependencies : None
"""
import ctypes
import enum
import threading
import time
from ctypes import (
    windll,
    wintypes)


class MOUSEINPUT(ctypes.Structure):
    """Contains information about a simulated mouse event.
    """
    MOVE = 0x0001
    ABSOLUTE = 0x8000
    LEFTDOWN = 0x0002
    LEFTUP = 0x0004
    LEFTCLICK = LEFTDOWN + LEFTUP
    RIGHTDOWN = 0x0008
    RIGHTUP = 0x0010
    RIGHTCLICK = RIGHTDOWN + RIGHTUP
    MIDDLEDOWN = 0x0020
    MIDDLEUP = 0x0040
    MIDDLECLICK = MIDDLEDOWN + MIDDLEUP
    XDOWN = 0x0080
    XUP = 0x0100
    WHEEL = 0x0800
    HWHEEL = 0x1000

    XBUTTON1 = 0x0001
    XBUTTON2 = 0x0002

    _fields_ = [
        ('dx', wintypes.LONG),
        ('dy', wintypes.LONG),
        ('mouseData', wintypes.DWORD),
        ('dwFlags', wintypes.DWORD),
        ('time', wintypes.DWORD),
        ('dwExtraInfo', ctypes.c_void_p)]


class KEYBDINPUT(ctypes.Structure):
    """Contains information about a simulated keyboard event.
    """
    EXTENDEDKEY = 0x0001
    KEYUP = 0x0002
    SCANCODE = 0x0008
    UNICODE = 0x0004

    _fields_ = [
        ('wVk', wintypes.WORD),
        ('wScan', wintypes.WORD),
        ('dwFlags', wintypes.DWORD),
        ('time', wintypes.DWORD),
        ('dwExtraInfo', ctypes.c_void_p)]


class HARDWAREINPUT(ctypes.Structure):
    """Contains information about a simulated message generated by an input
    device other than a keyboard or mouse.
    """
    _fields_ = [
        ('uMsg', wintypes.DWORD),
        ('wParamL', wintypes.WORD),
        ('wParamH', wintypes.WORD)]


class INPUTUNION(ctypes.Union):
    """Represents the union of input types in :class:`INPUT`.
    """
    _fields_ = [
        ('mi', MOUSEINPUT),
        ('ki', KEYBDINPUT),
        ('hi', HARDWAREINPUT)]


class INPUT(ctypes.Structure):
    """Used by :attr:`SendInput` to store information for synthesizing input
    events such as keystrokes, mouse movement, and mouse clicks.
    """
    MOUSE = 0
    KEYBOARD = 1
    HARDWARE = 2

    _fields_ = [
        ('type', wintypes.DWORD),
        ('value', INPUTUNION)]


class Button(enum.Enum):
    """The various buttons.
    """
    unknown = None
    left = (MOUSEINPUT.LEFTUP, MOUSEINPUT.LEFTDOWN, 0)
    middle = (MOUSEINPUT.MIDDLEUP, MOUSEINPUT.MIDDLEDOWN, 0)
    right = (MOUSEINPUT.RIGHTUP, MOUSEINPUT.RIGHTDOWN, 0)
    x1 = (MOUSEINPUT.XUP, MOUSEINPUT.XDOWN, MOUSEINPUT.XBUTTON1)
    x2 = (MOUSEINPUT.XUP, MOUSEINPUT.XDOWN, MOUSEINPUT.XBUTTON2)


class Mouse:
    LPINPUT = ctypes.POINTER(INPUT)
    WHEEL_DELTA = 120

    def __init__(self):

        self.send_input = windll.user32.SendInput
        self.user32 = windll.user32
        self.send_input.argtypes = (
            wintypes.UINT,
            ctypes.POINTER(INPUT),
            ctypes.c_int)

    @property
    def position(self):
        """ The current position of the mouse pointer.
            This is the tuple ``(x, y)``, and setting it will move the pointer."""
        return self._position_get()

    @position.setter
    def position(self, pos):
        self._position_set(pos)

    def scroll(self, dx, dy):
        """ Sends scroll events.
            int dx: The horizontal scroll. The units of scrolling is undefined.
            int dy: The vertical scroll. The units of scrolling is undefined.
            raises ValueError: if the values are invalid, for example out of bounds """
        self._scroll(dx, dy)

    def press(self, button):
        """ Emits a button press event at the current position.
            Button button: The button to press. """
        self._press(button)

    def release(self, button):
        """ Emits a button release event at the current position.
            Button button: The button to release."""
        self._release(button)

    def move(self, dx, dy):
        """ Moves the mouse pointer a number of pixels from its current position.
            int dx: The horizontal offset.
            int dy: The vertical offset.
            raises ValueError: if the values are invalid, for example out of bounds """
        self.position = tuple(sum(i) for i in zip(self.position, (dx, dy)))

    def move_to(self, x, y, speed=0, func=None):
        """ Moves the mouse pointer from its current position at set speed.
            int x: The new x coordinate.
            int y: The new y coordinate.
            int/float speed: (..-2, -1, 0, 1, 2..) positive speeds up, negative slows down
            function func: A function to be called between each move.
                Always supplies position, relative move, previous position as last three args.
            raises ValueError: if the values are invalid, for example out of bounds

            Call with: mouse.move_to(x, y, -4, lambda args: my_function(any_extra_arguments, *args))
            Define function as def my_function(any_extra_arguments, *args)
            To retrieve position information first line in function should be: pos, rel, o_pos = args[-3:] """
        px = ctypes.c_long(self.position[0]).value
        py = ctypes.c_long(self.position[1]).value
        path = self._line(px, py, x, y)
        if speed >= 0:
            speed = int(speed)
            if speed == 0:
                speed = 1
            i = 0
            while i < len(path):
                self.position = path[i]
                i += speed
        elif speed < 0:
            for pt in path:
                prev_position = self.position
                self.position = pt
                if func:
                    pos, rel, o_pos = self._get_move(self.position, prev_position)
                    func((pos, rel, o_pos))
                time.sleep(abs(speed) * 0.005)
        self.position = path[-1]

    def click(self, button, count=1):
        """ Emits a button click event at the current position.
            The default implementation sends a series of press and release events.
            Button button: The button to click.
            int count: The number of clicks to send. """
        for _ in range(count):
            self.press(button)
            self.release(button)

    def drag(self, dx, dy):
        """ Drag the mouse pointer from current position to end position.
            int dx: The horizontal offset.
            int dy: The vertical offset.
            raises ValueError: if the values are invalid, for example out of bounds """
        self.press(Button.left)
        self.move(dx, dy)
        self.release(Button.left)

    def drag_to(self, x, y, speed=0, func=None):
        """ Moves the mouse pointer from its current position at set speed.
            int x: The new x coordinate.
            int y: The new y coordinate.
            int/float speed: (..-2, -1, 0, 1, 2..) positive speeds up, negative slows down
            function func: A function to be called between each move.
                Always supplies position, relative move, previous position as last three args.
            raises ValueError: if the values are invalid, for example out of bounds

            Call with: mouse.move_to(x, y, -4, lambda args: my_function(any_extra_arguments, *args))
            Define function as def my_function(any_extra_arguments, *args)
            To retrieve position information first line in function should be: pos, rel, o_pos = args[-3:] """
        dragThread = threading.Thread(target=self._drag_pr, args=(x, y, speed, func))
        dragThread.start()
        dragThread.join()

    def get_screenpos(self, x, y):
        """ Translate active window coordinates to screen coordinates
            int x: The x coordinate.
            int y: The y coordinate.
            Returns tuple (x, y) of screen coordinates
        """
        point = wintypes.POINT(x, y)
        hwind = self.user32.GetActiveWindow()
        windll.user32.ClientToScreen(hwind, ctypes.byref(point))
        return ctypes.c_long(point.x).value, ctypes.c_long(point.y).value

    def get_clientpos(self, x, y):
        """ Translate screen coordinates to active window coordinates
            int x: The x coordinate.
            int y: The y coordinate.
            Returns tuple (x, y) of window coordinates
        """
        point = wintypes.POINT(x, y)
        hwind = self.user32.GetActiveWindow()
        windll.user32.ScreenToClient(hwind, ctypes.byref(point))
        return ctypes.c_long(point.x).value, ctypes.c_long(point.y).value

    def _drag_pr(self, x, y, speed, func):
        """ Drag executed in thread """
        self.press(Button.left)
        self.move_to(x, y, speed, func)
        self.release(Button.left)

    @staticmethod
    def _line(x0: int, y0: int, x1: int, y1: int):
        """ Bresenham's line algorithm
            Create list of points
            between (x0, y0) and (x1, y1) """
        points_in_line = []
        dx = abs(x1 - x0)
        dy = abs(y1 - y0)
        x, y = x0, y0
        sx = -1 if x0 > x1 else 1
        sy = -1 if y0 > y1 else 1
        if dx > dy:
            err = dx / 2.0
            while x != x1:
                points_in_line.append((x, y))
                err -= dy
                if err < 0:
                    y += sy
                    err += dx
                x += sx
        else:
            err = dy / 2.0
            while y != y1:
                points_in_line.append((x, y))
                err -= dx
                if err < 0:
                    x += sx
                    err += dy
                y += sy
        points_in_line.append((x, y))
        return points_in_line

    def _get_move(self, pos, old_pos):
        """ Return position and relative movement in client coordinates
            tuple pos: current position int tuple.
            tuple old_pos: previous position int tuple.
            Returns three tuples [position, relative change, prev position] in client coordinates
        """
        cpos = self.get_clientpos(pos[0], pos[1])
        copos = self.get_clientpos(old_pos[0], old_pos[1])
        return cpos, tuple(x - y for x, y in zip(cpos, copos)), copos

    @staticmethod
    def _position_get():
        point = wintypes.POINT()
        if windll.user32.GetCursorPos(ctypes.byref(point)):
            return point.x, point.y
        else:
            return None

    @staticmethod
    def _position_set(pos):
        pos = int(pos[0]), int(pos[1])
        windll.user32.SetCursorPos(*pos)

    def _scroll(self, dx, dy):
        if dy:
            self.send_input(1,
                            ctypes.byref(INPUT(type=INPUT.MOUSE,
                                               value=INPUTUNION(mi=MOUSEINPUT(dwFlags=MOUSEINPUT.WHEEL,
                                                                              mouseData=int(dy * self.WHEEL_DELTA))
                                                                )
                                               )
                                         ), ctypes.sizeof(INPUT))

        if dx:
            self.send_input(1,
                            ctypes.byref(INPUT(type=INPUT.MOUSE,
                                               value=INPUTUNION(mi=MOUSEINPUT(dwFlags=MOUSEINPUT.HWHEEL,
                                                                              mouseData=int(dx * self.WHEEL_DELTA))
                                                                )
                                               )
                                         ), ctypes.sizeof(INPUT))

    def _press(self, button):
        self.send_input(1,
                        ctypes.byref(INPUT(type=INPUT.MOUSE,
                                           value=INPUTUNION(mi=MOUSEINPUT(dwFlags=button.value[1],
                                                                          mouseData=button.value[2])
                                                            )
                                           )
                                     ), ctypes.sizeof(INPUT))

    def _release(self, button):
        self.send_input(1,
                        ctypes.byref(INPUT(type=INPUT.MOUSE,
                                           value=INPUTUNION(mi=MOUSEINPUT(dwFlags=button.value[0],
                                                                          mouseData=button.value[2])
                                                            )
                                           )
                                     ), ctypes.sizeof(INPUT))
